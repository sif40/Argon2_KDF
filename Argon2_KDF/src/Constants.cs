using Argon2_KDF.model;

namespace Argon2_KDF
{
    public class Constants
    {
        /* Memory block size in bytes */
        public const int ARGON2_BLOCK_SIZE = 1024;
        public const int ARGON2_QWORDS_IN_BLOCK = ARGON2_BLOCK_SIZE / 8;
        /* Number of pseudo-random values generated by one call to Blake in Argon2i
           to
           generate reference block positions
         */
        public const int ARGON2_ADDRESSES_IN_BLOCK = 128;
        /* Pre-hashing digest length and its extension*/
        public const int ARGON2_PREHASH_DIGEST_LENGTH = 64;
        public const int ARGON2_PREHASH_SEED_LENGTH = 72;
        /* Number of synchronization points between lanes per pass */
        public const int ARGON2_SYNC_POINTS = 4;
        /* Flags to determine which fields are securely wiped (default = no wipe). */
        public const int ARGON2_DEFAULT_FLAGS = 0;
        public const int ARGON2_VERSION_10 = 0x10;
        public const int ARGON2_VERSION_13 = 0x13;

        public static class Defaults
        {

            public const int OUTLEN_DEF = 32;
            public const int T_COST_DEF = 3;
            public const int LOG_M_COST_DEF = 12;
            public const int LANES_DEF = 1;
            public const Argon2Type TYPE_DEF = Argon2Type.Argon2i;
            public const int VERSION_DEF = ARGON2_VERSION_13;
            public const int ARGON2_VERSION_NUMBER = ARGON2_VERSION_13;
            public const bool ENCODED_ONLY = false;
            public const bool RAW_ONLY = false;
        }
        //public static int ARGON2_FLAG_CLEAR_PASSWORD (UINT32_C(1) << 0)
        //public static int ARGON2_FLAG_CLEAR_SECRET (UINT32_C(1) << 1)

        /*
        * Argon2 input parameter restrictions
        */
        public static class Constraints
        {

            public const int MAX_PASSWORD_LEN = 128;

            /* Minimum and maximum number of lanes (degree of parallelism) */
            public const int MIN_PARALLELISM = 1;
            public const int MAX_PARALLELISM = 16777216;

            /* Minimum and maximum digest size in bytes */
            public const int MIN_OUTLEN = 4;
            public const int MAX_OUTLEN = int.MaxValue;

            /* Minimum and maximum number of memory blocks (each of BLOCK_SIZE bytes) */
            public const int MIN_MEMORY = (2 * ARGON2_SYNC_POINTS); /* 2 blocks per slice */

            /* Minimum and maximum number of passes */
            public const int MIN_ITERATIONS = 1;
            public const int MAX_ITERATIONS = int.MaxValue;

            /* Minimum and maximum password length in bytes */
            public const int MIN_PWD_LENGTH = 0;
            public const int MAX_PWD_LENGTH = int.MaxValue;

            /* Minimum and maximum salt length in bytes */
            public const int MIN_SALT_LENGTH = 0;
            public const int MAX_SALT_LENGTH = int.MaxValue;

            /* Minimum and maximum key length in bytes */
            public const int MAX_SECRET_LENGTH = int.MaxValue;

            /* Minimum and maximum associated model length in bytes */
            public const int MAX_AD_LENGTH = int.MaxValue;
        }

        public static class Messages
        {
            public const string P_MIN_MSG = "degree of parallelism cannot be smaller than one";
            public const string P_MAX_MSG = "parallelism cannot be greater than 16777216";

            public const string M_MIN_MSG = "memory too small";

            public const string T_MIN_MSG = "number of iterations cannot be less than one";
            public const string T_MAX_MSG = "number of iterations too high";

            public const string PWD_MIN_MSG = "password too short";
            public const string PWD_MAX_MSG = "password too long";

            public const string SALT_MIN_MSG = "salt too short";
            public const string SALT_MAX_MSG = "salt too long";

            public const string SECRET_MAX_MSG = "secret too long";
            public const string ADDITIONAL_MAX_MSG = "additional data too long";
        }
    }
}
